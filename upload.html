<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Upload Your Music</title>
  <link rel="stylesheet" href="style.css">
  
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#00fff7">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Music Library">
  <link rel="apple-touch-icon" href="/icons/icon-192x192.png">
  <meta name="msapplication-TileColor" content="#00fff7">
  <meta name="msapplication-TileImage" content="/icons/icon-144x144.png">
</head>
<body>

<div class="top-nav">
    <div class="nav-left">
        <button class="nav-button" onclick="window.location.href='index.html'">
            &larr; Back to Home
        </button>
    </div>

    <div class="nav-right">
        <button class="nav-button" onclick="window.location.href='top-songs.html'" 
                style="background: linear-gradient(145deg, #ffd700, #ffaa00); color: black; margin-right: 10px;">
            ‚≠ê Top 50 Songs
        </button>
        <button class="nav-button" onclick="window.location.href='playlists.html'">
            Go to Playlists &rarr;
        </button>
    </div>
</div>

  <header>
    <h1>Upload Your Music</h1>
    <p>Add your own songs to your music library</p>
  </header>

  <section class="upload-section">

    <!-- DRAG & DROP AREA -->
    <div id="drop-area">
      <h3>Drag & Drop Songs Here</h3>
      <p>or click to upload</p>
      <input type="file" id="fileInput" accept="audio/*" multiple>
    </div>

    <!-- LIST OF UPLOADED SONGS -->
    <div class="uploaded-list">
      <h2>Your Uploaded Songs</h2>
      <ul id="songList"></ul>
    </div>

    <!-- AUDIO PLAYER -->
    <div class="audio-player-container">
      <h2>Now Playing</h2>
      <audio id="audioPlayer" controls></audio>
    </div>

  </section>

  <script>
    // DEBUG: Add this first to see what's happening
    console.log("=== UPLOAD PAGE LOADING ===");
    console.log("IndexedDB supported:", !!window.indexedDB);

    // IndexedDB Configuration
    const DB_NAME = 'MusicAppDB';
    const DB_VERSION = 1;
    const STORE_NAME = 'uploadedSongs';
    
    let db = null;
    let uploadedSongs = []; // This will store File objects in memory

    // Initialize IndexedDB
    function initDB() {
      return new Promise((resolve, reject) => {
        console.log("Opening IndexedDB...");
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        
        request.onerror = function(event) {
          console.error("‚ùå IndexedDB error:", event.target.error);
          reject(event.target.error);
        };
        
        request.onsuccess = function(event) {
          db = event.target.result;
          console.log("‚úÖ IndexedDB opened successfully");
          console.log("Database name:", db.name);
          console.log("Database version:", db.version);
          resolve();
        };
        
        request.onupgradeneeded = function(event) {
          const db = event.target.result;
          console.log("IndexedDB upgrade needed, creating store...");
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            const store = db.createObjectStore(STORE_NAME, { keyPath: 'name' });
            console.log("‚úÖ Created object store:", STORE_NAME);
          }
        };
        
        request.onblocked = function(event) {
          console.error("IndexedDB blocked (another tab has it open)");
          reject("Database blocked by another tab");
        };
      });
    }

    // Save a file to IndexedDB (UPDATED to save cacheUrl)
    function saveSongToDB(file) {
      return new Promise((resolve, reject) => {
        if (!db) {
          reject("Database not initialized");
          return;
        }
        
        console.log("Saving to IndexedDB:", file.name, "size:", file.size);
        
        const reader = new FileReader();
        reader.onload = function(event) {
          const songData = {
            name: file.name,
            type: file.type,
            size: file.size,
            lastModified: file.lastModified,
            data: event.target.result, // ArrayBuffer
            cacheUrl: file.cacheUrl || null  // ADDED: Save cache URL for PWA
          };
          
          console.log("File converted to ArrayBuffer, size:", songData.data.byteLength, "bytes");
          
          const transaction = db.transaction([STORE_NAME], 'readwrite');
          const store = transaction.objectStore(STORE_NAME);
          const request = store.put(songData);
          
          request.onsuccess = function() {
            console.log("‚úÖ Saved to IndexedDB:", file.name);
            resolve();
          };
          
          request.onerror = function(event) {
            console.error("‚ùå Error saving to IndexedDB:", event.target.error);
            reject(event.target.error);
          };
        };
        
        reader.onerror = function(event) {
          console.error("‚ùå FileReader error:", event.target.error);
          reject(event.target.error);
        };
        
        reader.onabort = function() {
          console.error("‚ùå FileReader aborted");
          reject("File read aborted");
        };
        
        reader.readAsArrayBuffer(file);
      });
    }

    // Load all songs from IndexedDB
    function loadSongsFromDB() {
      return new Promise((resolve, reject) => {
        if (!db) {
          reject("Database not initialized");
          return;
        }
        
        console.log("Loading songs from IndexedDB...");
        const transaction = db.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.getAll();
        
        request.onsuccess = function(event) {
          const songs = event.target.result || [];
          console.log("‚úÖ Loaded", songs.length, "songs from IndexedDB");
          resolve(songs);
        };
        
        request.onerror = function(event) {
          console.error("‚ùå Error loading from IndexedDB:", event.target.error);
          reject(event.target.error);
        };
      });
    }

    // Convert ArrayBuffer back to File object
    function arrayBufferToFile(arrayBuffer, fileName, fileType) {
      console.log("Converting ArrayBuffer to File:", fileName);
      const blob = new Blob([arrayBuffer], { type: fileType });
      return new File([blob], fileName, {
        type: fileType,
        lastModified: Date.now()
      });
    }

    // Delete a song from IndexedDB
    function deleteSongFromDB(songName) {
      return new Promise((resolve, reject) => {
        if (!db) {
          reject("Database not initialized");
          return;
        }
        
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.delete(songName);
        
        request.onsuccess = function() {
          console.log("Deleted from IndexedDB:", songName);
          resolve();
        };
        
        request.onerror = function(event) {
          console.error("Error deleting from IndexedDB:", event.target.error);
          reject(event.target.error);
        };
      });
    }

    // Create a song list item
    function createSongListItem(songName, file) {
      const li = document.createElement("li");
      li.textContent = songName;
      
      // Add double-click to delete
      li.addEventListener("dblclick", async function(e) {
        e.stopPropagation();
        if (confirm(`Delete "${songName}"?`)) {
          try {
            await deleteSongFromDB(songName);
            uploadedSongs = uploadedSongs.filter(s => s.name !== songName);
            li.remove();
            console.log("Deleted:", songName);
          } catch (error) {
            console.error("Failed to delete:", error);
            alert("Failed to delete song.");
          }
        }
      });
      
      // Add click to play
      li.addEventListener("click", function() {
        playSong(file);
      });
      
      return li;
    }

    // Play a song (UPDATED for PWA caching)
    function playSong(file) {
      console.log("Playing song:", file.name);
      const audioPlayer = document.getElementById("audioPlayer");
      
      // Try to use cached URL first, fall back to object URL
      if (file.cacheUrl) {
        console.log("Using cached URL:", file.cacheUrl);
        audioPlayer.src = file.cacheUrl;
      } else {
        const objectURL = URL.createObjectURL(file);
        audioPlayer.src = objectURL;
        
        // Clean up URL when done
        audioPlayer.addEventListener('ended', function cleanup() {
          URL.revokeObjectURL(objectURL);
          audioPlayer.removeEventListener('ended', cleanup);
        }, { once: true });
      }
      
      audioPlayer.play();
      
      // Highlight playing song
      document.querySelectorAll("#songList li").forEach(li => {
        li.classList.remove("playing");
        if (li.textContent === file.name) {
          li.classList.add("playing");
        }
      });
    }

    // Handle file uploads (UPDATED for PWA caching)
    async function handleFiles(files) {
      console.log("handleFiles called with", files.length, "file(s)");
      
      // REMOVE THE "NO SONGS UPLOADED YET" PLACEHOLDER IF IT EXISTS
      if (songList.children.length === 1) {
        const firstChild = songList.children[0];
        if (firstChild.textContent === "No songs uploaded yet" || 
            firstChild.textContent.includes("No songs") ||
            firstChild.style.color === "#888") {
          firstChild.remove();
          console.log("Removed placeholder message");
        }
      }
      
      for (let file of files) {
        if (!file.type.startsWith("audio/")) {
          alert(`"${file.name}" is not an audio file. Skipped.`);
          continue;
        }
        
        console.log("Processing:", file.name, "type:", file.type, "size:", file.size);
        
        // Check if song already exists
        if (uploadedSongs.some(s => s.name === file.name)) {
          if (!confirm(`"${file.name}" already exists. Replace?`)) {
            continue;
          }
          // Remove existing
          await deleteSongFromDB(file.name);
          uploadedSongs = uploadedSongs.filter(s => s.name !== file.name);
          // Remove from UI
          const existingLi = Array.from(songList.children).find(li => li.textContent === file.name);
          if (existingLi) existingLi.remove();
        }
        
        try {
          // Save to IndexedDB
          await saveSongToDB(file);
          
          // Add to memory
          uploadedSongs.push({
            name: file.name,
            file: file
          });
          
          // Add to UI
          const li = createSongListItem(file.name, file);
          songList.appendChild(li);
          
          console.log("‚úÖ Successfully added:", file.name);
          
          // ========== PWA CACHING ==========
          // Also cache in Service Worker for offline PWA support
          if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
            try {
              // Create a unique URL for this cached audio
              const cacheUrl = `/cached-audio/${Date.now()}-${encodeURIComponent(file.name)}`;
              
              // Convert File to blob
              const blob = new Blob([await file.arrayBuffer()], { type: file.type });
              
              // Send to Service Worker for caching
              navigator.serviceWorker.controller.postMessage({
                type: 'CACHE_AUDIO',
                url: cacheUrl,
                blob: blob,
                fileName: file.name
              });
              
              console.log("üì¶ Sent to Service Worker for caching:", file.name);
              
              // Store the cache URL with the file for later playback
              file.cacheUrl = cacheUrl;
              
              // Update IndexedDB with the cache URL
              await saveSongToDB(file); // Save again with cacheUrl
              
            } catch (swError) {
              console.warn("‚ö†Ô∏è Could not cache in Service Worker:", swError);
              // Non-critical error - file is still saved in IndexedDB
            }
          }
          // =================================
          
        } catch (error) {
          console.error("‚ùå Failed to save file:", file.name, error);
          if (error.name === 'QuotaExceededError') {
            alert(`Failed to save "${file.name}". Your browser storage is full.`);
          } else {
            alert(`Failed to save "${file.name}". File might be too large.`);
          }
        }
      }
    }

    // Main application code
    document.addEventListener('DOMContentLoaded', async function() {
      const dropArea = document.getElementById("drop-area");
      const fileInput = document.getElementById("fileInput");
      const songList = document.getElementById("songList");

      console.log("DOM loaded, initializing...");

      try {
        // Initialize database
        await initDB();
        
        // Load and display existing songs
        const savedSongs = await loadSongsFromDB();
        console.log("Found", savedSongs.length, "saved songs");
        
        // CLEAR THE LIST BEFORE ADDING SONGS
        songList.innerHTML = '';
        
        if (savedSongs.length > 0) {
          savedSongs.forEach(songData => {
            console.log("Loading saved song:", songData.name);
            // Convert ArrayBuffer back to File
            const file = arrayBufferToFile(songData.data, songData.name, songData.type);
            
            // ADDED: Restore cacheUrl from IndexedDB
            if (songData.cacheUrl) {
              file.cacheUrl = songData.cacheUrl;
              console.log("Restored cache URL:", songData.cacheUrl);
            }
            
            // Add to memory array
            uploadedSongs.push({
              name: songData.name,
              file: file
            });
            
            // Create list item
            const li = createSongListItem(songData.name, file);
            songList.appendChild(li);
          });
          console.log("‚úÖ Displayed", uploadedSongs.length, "songs");
        } else {
          console.log("‚ÑπÔ∏è No saved songs found");
          // Only add placeholder if the list is completely empty
          if (songList.children.length === 0) {
            songList.innerHTML = '<li style="color:#888; font-style:italic;">No songs uploaded yet</li>';
          }
        }
        
      } catch (error) {
        console.error("‚ùå Failed to initialize database:", error);
        songList.innerHTML = '<li style="color:red;">Error loading songs. Please refresh.</li>';
      }

      // Event Listeners
      dropArea.addEventListener("click", () => {
        console.log("Drop area clicked");
        fileInput.click();
      });
      
      fileInput.addEventListener("change", (e) => {
        console.log("File input changed");
        handleFiles(e.target.files);
      });

      dropArea.addEventListener("dragover", (e) => {
        e.preventDefault();
        dropArea.classList.add("highlight");
      });

      dropArea.addEventListener("dragleave", () => {
        dropArea.classList.remove("highlight");
      });

      dropArea.addEventListener("drop", (e) => {
        e.preventDefault();
        dropArea.classList.remove("highlight");
        console.log("Files dropped");
        handleFiles(e.dataTransfer.files);
      });
      
      // Clear all songs (for testing)
      window.clearAllSongs = async function() {
        if (confirm("Delete ALL uploaded songs?")) {
          try {
            const transaction = db.transaction([STORE_NAME], 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.clear();
            
            request.onsuccess = function() {
              uploadedSongs = [];
              songList.innerHTML = '';
              console.log("All songs deleted");
              alert("All songs deleted");
            };
          } catch (error) {
            console.error("Failed to clear songs:", error);
          }
        }
      };
    });
  </script>

</body>
</html>